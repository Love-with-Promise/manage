<h3>Volatile实现原理</h3>
Volatile修饰的共享变量转换成汇编代码的时候，会有一个Lock前缀的指令。</br>
<ul>
<li>Lock前缀指令会引起处理器缓存会写到内存
<li>一个处理器的缓存回写到内存会导致其他处理器的缓存无效
</ul>

<h3>Synchronized实现原理</h3>
Volatile修饰的共享变量转换成汇编代码的时候，会有一个Lock前缀的指令。</br>
<ul>
<li>对于普通同步方法，锁是当前实例对象
<li>对于静态同步方法，锁是当前类的class对象
<li>同步方法块，锁是Synchronized括号里配置的对象
</ul>

锁的4中状态级别由低到高：无锁状态，偏向锁状态，轻量级锁状态，重量级锁状态，，这几个情况会随着竞争状态逐渐升级，锁可以升级但不能降级。</br>
Java对象头里面默认存储对象的：HashCode，分代年龄，锁标记位，锁状态，是否是偏向锁。</br>

CAS实现原子操作的三大问题</br>
ABA问题，循环时间长开销大，只能保证一个共享变量的原子操作。</br>

重排序：是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。</br>
数据的依赖性：如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。
<table>
  <tr><td>名称<td>写后读<td>写后写<td>读后写
  <tr><td>代码示例<td>a=1;b=a;<td>a=1;a=2<td>a=b;b=1
  <tr><td>说明<td>写一个变量之后，再读这个变量<td>一个变量之后，再写这个变量<td>一个变量之后，再写这个变量
</table>    
    
在单线程中，编译器和处理器在做重排序的时候，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。但在多线程中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</br>
当写一个volatile变量时，JMM会把改线程对应的本地内存中的共享变量值刷新到主内存。</br>
当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效线程接下来会从主存中读取共享变量。</br>
<h4>锁读取与volatile读有相同的语义，锁释放与volatile写有相同的语义。
<ul>
<li>线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（线程A对共享变量做出修改的）消息
<li>线程B获取了一个锁，实质上是线程B接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息
<li>线程A释放锁，线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息
 
 <h4>双重检查锁定与延迟初始化
  在Java多线程程序中，有时候需要采用延迟初始化来降低初始化类和创建对象的开销。
  
<h4>为什么要用多线程
<ul>
<li>更多的处理器核心：随着处理器核心说的越来越多，使用多线程技术将计算逻辑分配到多个处理器核心上，会显著减少程序的处理时间
<li>更快的响应时间：处理复杂的业务逻辑，使用多线程技术可以响应用户请求的线程能够尽快的处理完成，缩短了响应时间，提升了用户体验。
<li>更好的编程模型：Java为多线程编程提供了良好并且一致性的编程模型，是开发人员更加专注于问题的解决。
  
<h4>虚拟机调优命令
<ul>
<li>jps:虚拟机进程状况工具。列出正在运行的虚拟机进程，显示虚拟机执行主类的名称及这些进程的本地虚拟机唯一的ID（Local Virtual Machine Identifier,LVMID）
<li>jstack:Java堆栈跟踪工具。生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的目的是定位线程出现长时间停顿的原因。线程出现停顿的时候通过jstack来查看各个线程的调用堆栈。
