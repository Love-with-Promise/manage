<h3>Volatile实现原理</h3>
Volatile修饰的共享变量转换成汇编代码的时候，会有一个Lock前缀的指令。</br>
<ul>
<li>Lock前缀指令会引起处理器缓存会写到内存
<li>一个处理器的缓存回写到内存会导致其他处理器的缓存无效
</ul>

<h3>Synchronized实现原理</h3>
Volatile修饰的共享变量转换成汇编代码的时候，会有一个Lock前缀的指令。</br>
<ul>
<li>对于普通同步方法，锁是当前实例对象
<li>对于静态同步方法，锁是当前类的class对象
<li>同步方法块，锁是Synchronized括号里配置的对象
</ul>

锁的4中状态级别由低到高：无锁状态，偏向锁状态，轻量级锁状态，重量级锁状态，，这几个情况会随着竞争状态逐渐升级，锁可以升级但不能降级。</br>
Java对象头里面默认存储对象的：HashCode，分代年龄，锁标记位，锁状态，是否是偏向锁。</br>

CAS实现原子操作的三大问题</br>
ABA问题，循环时间长开销大，只能保证一个共享变量的原子操作。</br>

重排序：是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。</br>
数据的依赖性：如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。
<table>
  <tr><td>名称<td>写后读<td>写后写<td>读后写
  <tr><td>代码示例<td>a=1;b=a;<td>a=1;a=2<td>a=b;b=1
  <tr><td>说明<td>写一个变量之后，再读这个变量<td>一个变量之后，再写这个变量<td>一个变量之后，再写这个变量
</table>    
    
在单线程中，编译器和处理器在做重排序的时候，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。但在多线程中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</br>
当写一个volatile变量时，JMM会把改线程对应的本地内存中的共享变量值刷新到主内存。</br>
当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效线程接下来会从主存中读取共享变量。</br>
<h4>锁读取与volatile读有相同的语义，锁释放与volatile写有相同的语义。
<ul>
<li>线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（线程A对共享变量做出修改的）消息
<li>线程B获取了一个锁，实质上是线程B接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息
<li>线程A释放锁，线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息
</ul>
<h4>双重检查锁定与延迟初始化</h4>
 在Java多线程程序中，有时候需要采用延迟初始化来降低初始化类和创建对象的开销。</br>
  
<h4>为什么要用多线程</h4>
<ul>
<li>更多的处理器核心：随着处理器核心说的越来越多，使用多线程技术将计算逻辑分配到多个处理器核心上，会显著减少程序的处理时间
<li>更快的响应时间：处理复杂的业务逻辑，使用多线程技术可以响应用户请求的线程能够尽快的处理完成，缩短了响应时间，提升了用户体验。
<li>更好的编程模型：Java为多线程编程提供了良好并且一致性的编程模型，是开发人员更加专注于问题的解决。
</ul>  
<h4>虚拟机调优命令</h4>
<ul>
<li>jps:虚拟机进程状况工具。列出正在运行的虚拟机进程，显示虚拟机执行主类的名称及这些进程的本地虚拟机唯一的ID（Local Virtual Machine Identifier,LVMID）
<li>jstack:Java堆栈跟踪工具。生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的目的是定位线程出现长时间停顿的原因。线程出现停顿的时候通过jstack来查看各个线程的调用堆栈。
<li>jstat:虚拟机统计信息监视工具。用于监视虚拟机各种运行状态信息的命令行工具，显示虚拟机进程中的类装载-class、垃圾收集-gc、运行期编译情况-compiler
<li>jmap:Java内存映像工具。用于生成堆转储快照（dump文件）：获取dump文件-dump，查询finalize执行队列-finalizeinfo，Java堆-heap和永久代-permstat的详细信息。
<li>jhat:虚拟机堆转储快照分析工具。用来分析jmap生成的堆转储快照
<li>jinfo:Java配置信息工具。实时查看和调整虚拟机各项参数。
</ul>  
<h4>线程间通信</h4>
<ul>
  <li>Volatile和synchronized的关键字
  <li>等待通知机制 wait()和notify()
  <li>管道输入输出流
  <li>Thread.join的使用
  <li>ThreadLocal的使用
</ul>
<h4>synchronized的关键字的实现细节</h4>
对于同步块使用了monitorenter和monitorexit指令，同步方式依靠方法上面的ACC_SYNCHRONIZED来完成。其本质是对一个对象的监视器进行获取，而这个获取是排他的，也就是同一个时刻只能有一个线程获取到有synchronized所保护对象的监视器。</br>
任意一个对象都有一个自己的监视器，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取到该对象的监视器才能进入同步块或者同步方法，而没有获取到监视器的线程将会被阻塞在同步块和同步方法的入口处，进入BLOCKED状态。</br>

<h4>队列同步器</h4>
队列同步器（AbstractQueuedSynchronizer,AQS）,用来构建锁或者其他同步组件的基础框架，它使用一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源
获取线程的排队工作。</br>
同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态，对同步状态的修改通过同步器提供的三个方法（getState(),setState(int newState)和compareAndSetState(int expect,int update)),他们能够保证状态的改变是安全的，同步器既可以支持独占式的获取同步状态，也可以支持共享式的获取同步状态。</br>

重入锁：支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。重进入是指任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞。</br>
读写锁：读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁读写锁能够简化读写交互场景的编程方式。（ReadWriteLock定义了获取读锁和写锁的两个方法，即readLock()和writeLock(),而其实现是ReentrantReadWriteLock）</br>
LockSupport工具：LockSupport定义了一组公共静态方法，这些方法提供了最基本的线程阻塞和唤醒功能，而LockSupport也成为构建同步组件的基础工具。park()阻塞当前线程，unpark（）唤醒一个被阻塞的线程。
<h4>阻塞队列</h4>
阻塞队列是一个支持两个附加操作的队列。这两个附加操作支持阻塞的插入和移除方法。
插入方法：当队列满时，队列会阻塞插入元素的线程，直到队列不满；移除方法：当队列为空时，获取元素的线程会等待队列变为非空。
阻塞队列常用于生产者和消费者的场景，是生产者用来存放元素，消费者用来获取元素的容器。</br>
Java提供的7个阻塞队列
<ul>
<li>ArrayBlockingQueue:一个由数组结构组成的有界阻塞队列。</br>此队列按照先进先出（FIFO）的原则对元素进行排序，但是默认情况下不保证线程公平的访问队列，即如果队列满了，那么被阻塞在外面的线程对队列访问的顺序是不能保证线程公平（即先阻塞，先插入）的。
<li>LinkedBlockingQueue:一个由链表结构组成的有界阻塞队列。
<li>PriorityBlockingQueue:一个支持优先级排序的无解阻塞队列。
<li>DelayQueue:一个使用优先级队列实现的无界阻塞队列。
<li>SynchronousQueue:一个不存储元素的阻塞队列。</br>每一个put必须等待一个take操作，否则不能继续添加元素。并且他支持公平访问队列。
<li>LinkedTransferQueue:一个由链表结构组成的无界阻塞队列。
<li>LinkedBlockingDeque:一个由链表结构组成的双向阻塞队列。
 </ul> 
阻塞队列的实现原理：使用通知模式实现，所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。例如ArrayBlockingQueue使用了Condition来实现。
<h4>Fork/Join框架</h4>
Fork/Join框架是一个并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。
工作窃取算法：指某个线程从其他队列里窃取任务来执行。
优点：充分利用线程进行并行计算，减少了线程间的竞争。
缺点：在某些情况下存在竞争，比如双端队列里只有一个任务的时候。

<h4>Atomic包提供了13个原子操作类</h4>
原子更新基本类型
<ul>
<li>AtomicBoolean:原子更新布尔类型
<li>AtomicInteger:原子更新整型
<li>AtomicLong:原子更新长整型
</ul>
原子更新数组  
<ul>
<li>AtomicReferenceArray:原子更新引用数组里的元素
<li>AtomicIntegerArray:原子更新长整型数组里的元素
<li>AtomicLongArray:原子更新整型数组里的元素
</ul>
原子更新引用  
<ul>
<li>AtomicReference:原子更新引用类型
<li>AtomicReferenceFieldUpdater:原子更新引用类型里的字段
<li>AtomicMarkableReference:原子更新带有标记位的引用类型
</ul>
原子更新基本类型 
<ul>
<li>AtomicStampedReference:原子更新带有版本号的引用类型
<li>AtomicIntegerFieldUpdater:原子更新整型的字段的更新器
<li>AtomicLongFieldUpdater:原子更新长整型字段的更新器
 </ul> 
<h4>Java中的并发工具类</h4>
