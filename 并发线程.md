<h3>Volatile实现原理</h3>
Volatile修饰的共享变量转换成汇编代码的时候，会有一个Lock前缀的指令。</br>
<ul>
<li>Lock前缀指令会引起处理器缓存会写到内存
<li>一个处理器的缓存回写到内存会导致其他处理器的缓存无效
</ul>

<h3>Synchronized实现原理</h3>
Volatile修饰的共享变量转换成汇编代码的时候，会有一个Lock前缀的指令。</br>
<ul>
<li>对于普通同步方法，锁是当前实例对象
<li>对于静态同步方法，锁是当前类的class对象
<li>同步方法块，锁是Synchronized括号里配置的对象
</ul>

锁的4中状态级别由低到高：无锁状态，偏向锁状态，轻量级锁状态，重量级锁状态，，这几个情况会随着竞争状态逐渐升级，锁可以升级但不能降级。</br>
Java对象头里面默认存储对象的：HashCode，分代年龄，锁标记位，锁状态，是否是偏向锁。</br>

CAS实现原子操作的三大问题</br>
ABA问题，循环时间长开销大，只能保证一个共享变量的原子操作。</br>

重排序：是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。</br>
数据的依赖性：如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。
<table>
  <tr><td>名称<td>写后读<td>写后写<td>读后写
  <tr><td>代码示例<td>a=1;b=a;<td>a=1;a=2<td>a=b;b=1
  <tr><td>说明<td>写一个变量之后，再读这个变量<td>一个变量之后，再写这个变量<td>一个变量之后，再写这个变量
</table>    
    
在单线程中，编译器和处理器在做重排序的时候，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。但在多线程中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</br>
当写一个volatile变量时，JMM会把改线程对应的本地内存中的共享变量值刷新到主内存。</br>
当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效线程接下来会从主存中读取共享变量。</br>
<h4>锁读取与volatile读有相同的语义，锁释放与volatile写有相同的语义。
<ul>
<li>线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（线程A对共享变量做出修改的）消息
<li>线程B获取了一个锁，实质上是线程B接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息
<li>线程A释放锁，线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息
</ul>
<h4>双重检查锁定与延迟初始化</h4>
 在Java多线程程序中，有时候需要采用延迟初始化来降低初始化类和创建对象的开销。</br>
  
<h4>为什么要用多线程</h4>
<ul>
<li>更多的处理器核心：随着处理器核心说的越来越多，使用多线程技术将计算逻辑分配到多个处理器核心上，会显著减少程序的处理时间
<li>更快的响应时间：处理复杂的业务逻辑，使用多线程技术可以响应用户请求的线程能够尽快的处理完成，缩短了响应时间，提升了用户体验。
<li>更好的编程模型：Java为多线程编程提供了良好并且一致性的编程模型，是开发人员更加专注于问题的解决。
</ul>  
<h4>虚拟机调优命令</h4>
<ul>
<li>jps:虚拟机进程状况工具。列出正在运行的虚拟机进程，显示虚拟机执行主类的名称及这些进程的本地虚拟机唯一的ID（Local Virtual Machine Identifier,LVMID）
<li>jstack:Java堆栈跟踪工具。生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的目的是定位线程出现长时间停顿的原因。线程出现停顿的时候通过jstack来查看各个线程的调用堆栈。
<li>jstat:虚拟机统计信息监视工具。用于监视虚拟机各种运行状态信息的命令行工具，显示虚拟机进程中的类装载-class、垃圾收集-gc、运行期编译情况-compiler
<li>jmap:Java内存映像工具。用于生成堆转储快照（dump文件）：获取dump文件-dump，查询finalize执行队列-finalizeinfo，Java堆-heap和永久代-permstat的详细信息。
<li>jhat:虚拟机堆转储快照分析工具。用来分析jmap生成的堆转储快照
<li>jinfo:Java配置信息工具。实时查看和调整虚拟机各项参数。
</ul>  
<h4>线程间通信</h4>
<ul>
  <li>Volatile和synchronized的关键字
  <li>等待通知机制 wait()和notify()
  <li>管道输入输出流
  <li>Thread.join的使用
  <li>ThreadLocal的使用
</ul>
<h4>synchronized的关键字的实现细节</h4>
对于同步块使用了monitorenter和monitorexit指令，同步方式依靠方法上面的ACC_SYNCHRONIZED来完成。其本质是对一个对象的监视器进行获取，而这个获取是排他的，也就是同一个时刻只能有一个线程获取到有synchronized所保护对象的监视器。</br>
任意一个对象都有一个自己的监视器，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取到该对象的监视器才能进入同步块或者同步方法，而没有获取到监视器的线程将会被阻塞在同步块和同步方法的入口处，进入BLOCKED状态。</br>

<h4>队列同步器</h4>
队列同步器（AbstractQueuedSynchronizer,AQS）,用来构建锁或者其他同步组件的基础框架，它使用一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源
获取线程的排队工作。</br>
同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态，对同步状态的修改通过同步器提供的三个方法（getState(),setState(int newState)和compareAndSetState(int expect,int update)),他们能够保证状态的改变是安全的，同步器既可以支持独占式的获取同步状态，也可以支持共享式的获取同步状态。</br>

重入锁：支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。重进入是指任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞。</br>
读写锁：读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁读写锁能够简化读写交互场景的编程方式。（ReadWriteLock定义了获取读锁和写锁的两个方法，即readLock()和writeLock(),而其实现是ReentrantReadWriteLock）</br>
LockSupport工具：LockSupport定义了一组公共静态方法，这些方法提供了最基本的线程阻塞和唤醒功能，而LockSupport也成为构建同步组件的基础工具。park()阻塞当前线程，unpark（）唤醒一个被阻塞的线程。
<h4>阻塞队列</h4>
阻塞队列是一个支持两个附加操作的队列。这两个附加操作支持阻塞的插入和移除方法。
插入方法：当队列满时，队列会阻塞插入元素的线程，直到队列不满；移除方法：当队列为空时，获取元素的线程会等待队列变为非空。
阻塞队列常用于生产者和消费者的场景，是生产者用来存放元素，消费者用来获取元素的容器。</br>
Java提供的7个阻塞队列
<ul>
<li>ArrayBlockingQueue:一个由数组结构组成的有界阻塞队列。</br>此队列按照先进先出（FIFO）的原则对元素进行排序，但是默认情况下不保证线程公平的访问队列，即如果队列满了，那么被阻塞在外面的线程对队列访问的顺序是不能保证线程公平（即先阻塞，先插入）的。
<li>LinkedBlockingQueue:一个由链表结构组成的有界阻塞队列。
<li>PriorityBlockingQueue:一个支持优先级排序的无解阻塞队列。
<li>DelayQueue:一个使用优先级队列实现的无界阻塞队列。
<li>SynchronousQueue:一个不存储元素的阻塞队列。</br>每一个put必须等待一个take操作，否则不能继续添加元素。并且他支持公平访问队列。
<li>LinkedTransferQueue:一个由链表结构组成的无界阻塞队列。
<li>LinkedBlockingDeque:一个由链表结构组成的双向阻塞队列。
 </ul> 
阻塞队列的实现原理：使用通知模式实现，所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。例如ArrayBlockingQueue使用了Condition来实现。
<h4>Fork/Join框架</h4>
Fork/Join框架是一个并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。
工作窃取算法：指某个线程从其他队列里窃取任务来执行。
优点：充分利用线程进行并行计算，减少了线程间的竞争。
缺点：在某些情况下存在竞争，比如双端队列里只有一个任务的时候。

<h4>Atomic包提供了13个原子操作类</h4>
原子更新基本类型
<ul>
<li>AtomicBoolean:原子更新布尔类型
<li>AtomicInteger:原子更新整型
<li>AtomicLong:原子更新长整型
</ul>
原子更新数组  
<ul>
<li>AtomicReferenceArray:原子更新引用数组里的元素
<li>AtomicIntegerArray:原子更新长整型数组里的元素
<li>AtomicLongArray:原子更新整型数组里的元素
</ul>
原子更新引用  
<ul>
<li>AtomicReference:原子更新引用类型
<li>AtomicReferenceFieldUpdater:原子更新引用类型里的字段
<li>AtomicMarkableReference:原子更新带有标记位的引用类型
</ul>
原子更新基本类型 
<ul>
<li>AtomicStampedReference:原子更新带有版本号的引用类型
<li>AtomicIntegerFieldUpdater:原子更新整型的字段的更新器
<li>AtomicLongFieldUpdater:原子更新长整型字段的更新器
 </ul> 
<h4>Java中的并发工具类</h4>
<strong>CountDownLatch:</strong>（等待多线程完成的CountDownLatch）允许一个或多个线程等待其他线程完成操作。</br>
<strong>CyclicBarrier[ˈsaɪklɪk][ˈbæriə(r)]:</strong>(同步屏障CyclicBarrier)让一组线程到达一个屏障（同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</br>
CyclicBarrier可以用于多线程计算数据，最后合并计算结果的场景。</br>
CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。所以CyclicBarrier能处理更为复杂的业务场景</br>
<strong>Semaphore[ˈseməfɔ:(r)]:</strong>（控制并发线程数的Semaphore）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。应用场景：可以用作流量控制，特别是公用资源有限的应用场景。</br>
<strong>Exchanger:</strong>（线程间交换数据的Exchanger）是一个用于线程间协作的工具类。用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。</br>
<h4>Java中线程池</h4>
Java中的线程池运用最多的是并发框架，使用线程池能够带来3个好处：
<ul>
<li><strong>降低资源消耗。</strong>通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
<li><strong>提高响应速度。</strong>当任务到达时，任务可以不需要等到线程创建就能立即执行。
<li><strong>提高线程的可管理性。</strong>线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配，调优和监控。
 </ul> 
 线程池的创建，new ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)</br>
 <ul>
<li>corePoolSize(线程池的基本大小)。
<li>workQueue(任务队列)：用于保存等待执行的任务的阻塞队列。
<li>maximumPoolSize（线程池的最大数量）：线程池允许创建的最大线程数。
<li>threadFactory：用于设置创建线程的工厂。
<li>RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，必须采取一种策略处理提交的新任务。
 <ul>
<li>AbortPolicy:直接抛出异常。
<li>CallerRunsPolicy：只用调用者所在线程来运行任务。
<li>DiscardOldestPolicy:丢弃队列里最近的一个任务，并执行当前任务。
<li>DiscardPolicy：不处理，不丢弃。
 </ul> 
<li>keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。
<li>TimeUnit（线程活动保持时间的单位）：
 </ul> 
<h4>向线程池提交任务</h4>
可以使用execute()和submit()向线程池提交任务。</br>
execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。</br>
submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，可以通过future的get()方法获取返回值。</br>
通过调用线程池的shutdown或者shutdownNow方法关闭线程池。他们的原理都是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的可能永远无法终止。</br>
<h3>Executor[ɪgˈzekjətə(r)]框架</h3>
Java的线程即是工作单元也是执行机制，工作单元包括Runnable和Callable，而执行机制由Executor框架提供。
<h4>Executor框架的结构</h4>
 <ul>
<li>任务。包括被执行任务需要实现的接口：Runnable接口或Callable接口。
<li>任务的执行。包括任务执行机制的核心接口Executor，以及继承自Executor的ExecutorService接口。
<li>异步计算的结果。包括接口Future和实现Future接口的FutureTask类。
 </ul> 
 Executor框架的成员：ThreadPoolExecutor、ScheduledThreadPoolExecutor、Future接口、Runnable接口、Callable接口和Executors。</br>
 <strong>ThreadPoolExecutor：</strong>通常使用工厂类Executors来创建，Executors可以创建3种类型的ThreadPoolExecutor：SingleThreadExecutor、FixedThreadPool、CachedThreadPool。</br>
  <ul>
<li>FixedThreadPool,创建使用固定线程数，适用于为了满足资源管理的需求，而需要限制当前线程数量的应用场景，它适用与负载比较重的服务器。
<li>SingleThreadExecutor：创建单个线程的，适用于需要保证顺序的执行各个任务，并在任意时间点，不会有多个线程活动的场景。
<li>CachedThreadPool：是大小无界的线程池，适用于执行很多的短期异步任务的小程序，或者负载较轻的服务器。。
 </ul> 
 
 <h4>FutureTask</h4>
FutureTask实现Future接口和Runnable接口，因为FutureTask可以交给Executor执行也可以调用线程直接执行（FutureTask.run()）.根据FutureTask.run（）方法被执行的时机，FutureTask可以处于以下3个状态。
 <ul>
<li>未启动，FutureTask.run()方法还没有被执行之前，FutureTask处于未启动状态。当创建一个FutureTask，且没有执行FutureTask.run（）方法之前，这个FutureTask处于未启动状态。
<li>已启动，FutureTask.run()方法被执行的过程中，FutureTask处于已启动状态。
<li>已完成，FutureTask.run()方法执行完成后正常结束，或被取消或执行FutureTask.run()方法时抛出异常而异常结束，FutureTask处于以完成状态。
 </ul> 
 FutureTask的实现基于AbstractQueuedSynchronizer，基于AQS实现的同步器包括：ReentrantLock、Semaphore、ReentrantReadWrireLock、CountDownLotch、FutureTask。
<h4> ReentrantLock</h4>
 ReentrantLock是可重入的独占锁，同时只能有一个线程可以获取锁，其他获取该锁的线程会被阻塞而放入该锁的AQS阻塞队列里面。AQS的state状态值表示线程获取该锁的可重入次数，状态值为0表示当前锁空闲，大于等于1表示锁已经被占用。锁内部有公平和非公平实现，默认情况是非公平实现。</br>
 <h4>ReentrantReadWriteLock</h4>
 ReentrantReadWriteLock采用读写分离的策略，允许多个线程可以同时访问读锁，读写锁内部维护了一个ReadLock和一个WriteLock，他们一来Sync实现具体的功能，它的底层使用AQS实现，使用AQS状态值的高16位表示获取到读锁的个数，低16位获取到写锁的可重入次数。适合读多写少的情况。
 
 <h4>线程的通知与等待</h4>
 wait函数，当一个线程调用一个共享变量的wait方法时，该调用线程会被阻塞挂起，直到：（1）其他线程调用了该共享对象的notify方法，（2）其他线程调用了该线程的interrupt方法。</br>
 notify函数，一个线程调用共享对象的notify方法后，会唤醒一个在该共享变量上调用wait系列方法后被挂起的线程，具体唤醒哪个等待的线程是随机的。
<h4>sleep方法</h4>
静态的sleep方法，当一个执行中的线程调用了Thread的sleep方法后，调用线程会暂时让出时间的执行权，在这期间不参与CPU的调度，但是该线程所拥有的监视器资源，比如锁还是不让出的。指定的时间到了之后，线程就会处于就绪状态，然后参与CPU的调度，获得CPU资源后就可以运行了

<h4>yield方法</h4>
当一个线程调用yield方法时，当前线程会让出CPU使用权，然后处于就绪状态，线程调度器会从线程就绪队列里面获取一个线程优先级更高的线程。
<h4>ThreadLocal</h4>
它提供了一个本地变量，也就是如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本。当多线程操作这个变量时，实际操作的是自己本地内存里面的变量。每个线程都会复制一个变量到自己的本地内存。</br>
