<h3>Volatile实现原理</h3>
Volatile修饰的共享变量转换成汇编代码的时候，会有一个Lock前缀的指令。</br>
<ul>
<li>Lock前缀指令会引起处理器缓存会写到内存
<li>一个处理器的缓存回写到内存会导致其他处理器的缓存无效
</ul>

<h3>Synchronized实现原理</h3>
Volatile修饰的共享变量转换成汇编代码的时候，会有一个Lock前缀的指令。</br>
<ul>
<li>对于普通同步方法，锁是当前实例对象
<li>对于静态同步方法，锁是当前类的class对象
<li>同步方法块，锁是Synchronized括号里配置的对象
</ul>

锁的4中状态级别由低到高：无锁状态，偏向锁状态，轻量级锁状态，重量级锁状态，，这几个情况会随着竞争状态逐渐升级，锁可以升级但不能降级。</br>
Java对象头里面默认存储对象的：HashCode，分代年龄，锁标记位，锁状态，是否是偏向锁。</br>

CAS实现原子操作的三大问题</br>
ABA问题，循环时间长开销大，只能保证一个共享变量的原子操作。</br>

重排序：是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。
数据的依赖性：如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。
<table>
  <tr><td>名称<td>写后读<td>写后写<td>读后写
  <tr><td>代码示例<td>a=1;b=a;<td>a=1;a=2<td>a=b;b=1
  <tr><td>说明<td>写一个变量之后，再读这个变量<td>一个变量之后，再写这个变量<td>一个变量之后，再写这个变量
